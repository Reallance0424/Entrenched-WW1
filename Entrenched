local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "Entrenched WW1 | why3",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "Loading Entrenched WW1",
    LoadingSubtitle = "by why3",
    Theme = "Amethyst", 

    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil, -- Create a custom folder for your hub/game
        FileName = "Big Hub"
    },

    Discord = {
        Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
        Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
        RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },

    KeySystem = true, -- Set this to true to use our key system
    KeySettings = {
        Title = "Entrenched WW1 Key System",
        Subtitle = "Key System",
        Note = "Ask why3 for key to access", -- Use this to tell the user how to get a key
        FileName = "Entrenched", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
        SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
        GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
        Key = {"09302010"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
})

local MainTab = Window:CreateTab("Home", nil)
local Main = MainTab:CreateSection("Aimbot")

local currentTarget = ""
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local Player = Players.LocalPlayer
local Char = Player.Character
local Mouse = Player:GetMouse()

local Root = Char:WaitForChild("HumanoidRootPart")
local Humanoid = Char:WaitForChild("Humanoid")
local Prediction_Enable = true
local SelectionBox = Instance.new("SelectionBox", script)
SelectionBox.Color3 = Color3.fromRGB(255, 255, 255)
SelectionBox.LineThickness = 0.02

local A_1 = false
local A_2 = false

local players = game:GetService("Players")

-- Table to store player names
local list1 = {}

-- Function to update the list with current player names
local function updatePlayerList()
    -- Clear the table
    list1 = {}

    -- Add each player's name to the table
    for _, player in ipairs(players:GetPlayers()) do
        if player.Character then
            if player.Character:WaitForChild("Humanoid").Health > 0 then
                table.insert(list1, player.Name)
            end
        end
    end

end

updatePlayerList()


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Function to get the closest player's head
local function isPlayerVisible(player)
    if player == LocalPlayer then return false end
    local character = player.Character
    if not character or not character:FindFirstChild("Head") then return false end

    local head = character.Head
    local screenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)

    -- Ensure the head is on screen and not obstructed
    if onScreen then
        local ray = Ray.new(Camera.CFrame.Position, (head.Position - Camera.CFrame.Position).Unit * 5000)
        local hitPart = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character, Camera})
        return hitPart and hitPart:IsDescendantOf(character)
    end

    return false
end

-- Function to find the closest player to the center of the screen
local function getClosestPlayerHead()
    local Players = game:GetService("Players")
    local closestPlayer = nil
    local closestDistance = math.huge
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do
        if player.Team ~= LocalPlayer.Team and isPlayerVisible(player) then
            local character = player.Character
            if not character then continue end
            if character and character:FindFirstChild("Head") and player.Character:FindFirstChild("Humanoid").Health>0 then
                local head = character.Head
                local screenPosition = Camera:WorldToViewportPoint(head.Position)
                local distanceToCenter = (Vector2.new(screenPosition.X, screenPosition.Y) - screenCenter).Magnitude

                if distanceToCenter < closestDistance then
                    closestPlayer = player
                    closestDistance = distanceToCenter
                end
            end
        end
    end

    return closestPlayer
end

local function getClosestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRootPart then return nil end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetRootPart = player.Character.HumanoidRootPart
            local distance = (localRootPart.Position - targetRootPart.Position).Magnitude

            if distance < closestDistance then
                closestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

-- Function to make the local player face the closest player
local function faceClosestPlayer()
    local localCharacter = LocalPlayer.Character
    local localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
    if not localRootPart then return end

    local closestPlayer = getClosestPlayer()
    if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetRootPart = closestPlayer.Character.HumanoidRootPart

        -- Calculate the direction vector
        local direction = (targetRootPart.Position - localRootPart.Position).Unit

        -- Update the CFrame to face the target
        localRootPart.CFrame = CFrame.new(localRootPart.Position, localRootPart.Position + direction)
    end
end

-- Variables to track "B" key state
local bKeyHeld = false

local aimbot=false

local Toggle=MainTab:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "aimbot", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        aimbot=(Value)
    end
})

local p = game.Workspace.Gravity

local Toggle = MainTab:CreateToggle({
    Name = "No Gravity",
    CurrentValue = false,
    Flag = "0Grav", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        if Value == true then
            local Player = game:GetService("Players").LocalPlayer
            game.Workspace.Gravity = 0
        end
        if Value == false then game.Workspace.Gravity = p end
    end
})
local Main = MainTab:CreateSection("Infinite Jump")
local Toggle = MainTab:CreateToggle({
    Name = "Inf Jump",
    CurrentValue = false,
    Flag = "INFJUMP", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        _G.infinjump = Value

        if _G.infinJumpStarted == nil then
            -- Ensures this only runs once to save resources
            _G.infinJumpStarted = true

            -- Notifies readiness
            game.StarterGui:SetCore("SendNotification", {
                Title = "Notification",
                Text = "Infinite Jump Activated!",
                Duration = 2
            })

            -- The actual infinite jump
            local plr = game:GetService('Players').LocalPlayer
            local m = plr:GetMouse()
            m.KeyDown:connect(function(k)
                if _G.infinjump then
                    if k:byte() == 32 then
                        humanoid = game:GetService 'Players'.LocalPlayer
                                       .Character:FindFirstChildOfClass(
                                       'Humanoid')
                        humanoid:ChangeState('Jumping')
                        wait()
                        humanoid:ChangeState('Seated')
                    end
                end
            end)
        end
    end
})
local Main = MainTab:CreateSection("ESP")
local Button = MainTab:CreateButton({
    Name = "Track all enemy/team",
    Callback = function()
        local Players = game:GetService("Players")

        -- Function to create or update a highlight for a player's character
        local function createHighlight(character)
            if not character then return end

            -- Check if the Highlight already exists
            local highlight = character:FindFirstChild("Highlight")
            if highlight then highlight:Destroy() end
            -- Create a new Highlight instance
            highlight = Instance.new("Highlight")
            highlight.Name = "Highlight"
            highlight.Adornee = character
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop -- Visible through walls
            if Players:GetPlayerFromCharacter(character).Team~=Players.LocalPlayer.Team then
                highlight.FillColor = Color3.new(1, 0.75, 0.796) -- Yellow glow (can be customized)
            else 
                highlight.FillColor = Color3.new(0, 1, 0)
            end
            highlight.FillTransparency = 0.3 -- Adjust transparency
            highlight.OutlineTransparency = 0 -- Fully visible outline
            highlight.Parent = character
        end

        -- Function to handle a player's character
        local function handlePlayerCharacter(player)
            player.CharacterAdded:Connect(function(character)
                -- Add highlight when the character loads
                createHighlight(character)
            end)

            -- If the character already exists, add the highlight immediately
            if player.Character then
                createHighlight(player.Character)
            end
        end

        -- Add highlights for all existing players
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= game:GetService("Players").LocalPlayer then
                handlePlayerCharacter(player)
            end
        end

        -- Listen for new players joining the game
        Players.PlayerAdded:Connect(function(player)
            handlePlayerCharacter(player)
        end)

    end
})

local plr = game:GetService("Players").LocalPlayer
local f = plr.Character.Humanoid.WalkSpeed

local Slider = MainTab:CreateSlider({
    Name = "Walkspeed",
    Range = {0, 300},
    Increment = 1,
    Suffix = "Walkspeed",
    CurrentValue = f,
    Flag = "WALKSPEED", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        game:GetService("Players").LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
    end
})

local j = plr.Character:WaitForChild("Humanoid").JumpPower

local Slider = MainTab:CreateSlider({
    Name = "Jump Power",
    Range = {0, 300},
    Increment = 1,
    Suffix = "Power",
    CurrentValue = j,
    Flag = "JUMPPOWER", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        game:GetService("Players").LocalPlayer.Character.Humanoid.JumpPower =
            (Value)
    end
})

local mh = game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid").MaxHealth
local h = game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid").Health

local Slider = MainTab:CreateSlider({
    Name = "Health",
    Range = {0, 10000000000},
    Increment = 10000,
    Suffix = "Health",
    CurrentValue = h,
    Flag = "HEALTH", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value)
        game:GetService("Players").LocalPlayer.Character.Humanoid.MaxHealth = (Value)
        game:GetService("Players").LocalPlayer.Character.Humanoid.Health = (Value)
        print(game:GetService("Players").LocalPlayer.Character.Humanoid.Health)
    end
})

local noclip = false

local Toggle = MainTab:CreateToggle({
    Name = "NoClip",
    CurrentValue = false,
    Flag = "NOCLIP", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value) noclip = Value end
})

local healthregen = false

local Toggle = MainTab:CreateToggle({
    Name = "Health Regen",
    CurrentValue = false,
    Flag = "regen", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
    Callback = function(Value) healthregen = (Value) end
})

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- Function to find the nearest player
local function getNearestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    local localCharacter = LocalPlayer.Character
    if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then
        return nil -- No local character or valid HumanoidRootPart
    end

    local localPosition = localCharacter.HumanoidRootPart.Position

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - localPosition).Magnitude
            if distance < shortestDistance then
                closestPlayer = player
                shortestDistance = distance
            end
        end
    end

    return closestPlayer
end

-- Function to teleport the local player 2 feet (0.6 studs) behind the nearest player
local function teleportBehindNearestPlayer()
    local nearestPlayer = getNearestPlayer()
    if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetRoot = nearestPlayer.Character.HumanoidRootPart
        local backPosition = targetRoot.CFrame * CFrame.new(0, 0, 0.6) -- Offset behind the target
        local localCharacter = LocalPlayer.Character

        if localCharacter and localCharacter:FindFirstChild("HumanoidRootPart") then
            localCharacter.HumanoidRootPart.CFrame = CFrame.new(backPosition.Position)
        end
    else
        print("No nearby player found.")
    end
end

local Button=MainTab:CreateButton({
    Name="TP Behind Player",
    Callback=function()
        teleportBehindNearestPlayer()
    end
})

RunService.RenderStepped:Connect(function()
    if healthregen then
        game:GetService("Players").LocalPlayer.Character.Humanoid.Health = game:GetService("Players")
                                                                 .LocalPlayer
                                                                 .Character
                                                                 .Humanoid
                                                                 .MaxHealth
    end
end)

RunService.RenderStepped:Connect(function()
    if noclip then
        for _, part in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") then part.CanCollide = false end
        end
    else
        for _, part in pairs(game:GetService("Players").LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") then part.CanCollide = true end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if aimbot then
        local closestHead = getClosestPlayerHead()
        if closestHead then
            -- Point the camera at the closest player's head
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, closestHead.Character.Head.Position)
        end
    end
end)
